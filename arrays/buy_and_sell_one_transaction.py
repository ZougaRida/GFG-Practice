from typing import Annotated
from annotated_types import Gt

type positive_int = Annotated[int, Gt(-1)]
# this means that the values 0, 1, 2, ... are valid and -1, -2, -3, ... are not
# too bad though that till this date 28/01/2026 with ty 0.0.11 (830cb9cc6 2026-01-09)
# doesn't implement the metadata as expected


def maximum_profit(prices: list[positive_int]) -> positive_int:
    """
    Calculate the maximum profit that can be achieved from a series of stock prices.

    Given a list of stock prices, this function computes the maximum possible profit
    from a single buy and sell operation. The profit is calculated based on the
    difference between the selling and buying prices. The function efficiently tracks
    **the cumulative minimal price from the left** *buying_price* and uses encoding to
    merge intermediate results into the original list.

    The time complexity of this function is `O(n)` where n is the length of the input
    list. The memory complexity is `O(1)`.

    https://www.geeksforgeeks.org/problems/buy-stock-2/1

    :param list[Annotated[int, Gt(-1)]] prices: A list of integers representing stock
           prices on different days.
    :return: The maximum profit achievable
    :rtype: Annotated[int, Gt(-1)]

    """

    # this documentation was generated by AI which keeps getting better
    # but true the trick here is to compute the cumulative minimum (buying_price) from
    # left and store it accordingly in cells by encoding since prices values are
    # restricted in the problem

    cumulative_min_price = encoder = 10001
    # okay first of all we set the encoder to 10**4 + 1
    # since prices are constrained to be <= encoder by the problem
    # and thus we can encode the cumulative_min_price values "in place" in the array by
    # the following trick prices[i] = prices[i] + encoder * cumulative_min_price,
    # it's like we're storing 2 values in one cell, if I want to access the old
    # prices[i] value, we compute prices[i] % encoder, if we want cumulative_min_price
    # then we compute prices[i] // encoder
    # REALLY POWERFUL TRICK!
    n = len(prices)

    for i in range(n):
        cumulative_min_price = min(cumulative_min_price, prices[i])
        prices[i] += encoder * cumulative_min_price

    # after all, if no profit can be made, we should return 0
    result = 0
    for i in range(n - 1, 0, -1):
        selling_price = prices[i] % encoder
        buying_price = prices[i] // encoder
        result = max(result, selling_price - buying_price)

    return result


if __name__ == "__main__":
    prices = [int(x) for x in input().split()]
    print(maximum_profit(prices))
